# Scala 介绍

##### Scala语言的特点

Scala是一门以JVM为运行环境并将**面向对象**和**函数式编程**的最佳特性结合在一起的静态类型编程语言。
1. Scala是一门多范式(multi-paradigm)的编程语言，Scala支持面向对象和函数式编程。
2. Scala源代码会被编译成java字节码，然后运行与JVM之上，并可以调用现有的Java类库，实现两种语言的无缝对接。
3. Scala在设计时，作者是参考了Java的设计思想，可以说Scala源于Java，同时他也加入了自己的设计思想，将函数式编程语言的特点融合到Java中。

# 第一章：注释

单行注释
```shell 
// 
```

多行注释
```shell 
/* */
```

文档注释
```shell 
/**
*/

scaladoc -d target_path source.scala
```

# 第二章：变量

```scala
val a:Short = 1

val b:Byte = 1

val age:Int = 10

val c:Long = 10

// 在scala中，小数默认为double类型，整数默认为Int类型
var score:Float = 99.9f

val salary:Double = 10.0

val isPass:Boolean = true

val gender:Char = 'M'

val name:String = "zhang san"
```


变量声明基本语法：
- var | val 


注意事项：
- 声明变量时，类型可以省略（编译器自动推导，即类型推导）
- 类型确定后，就不能修改，说明Scala是强数据类型语言
- 在声明一个变量时，可以使用var或者val来修饰，var修饰可变变量，val修饰不可变变量
- val修饰的变量在编译后，等同于加上了final
- 变量声明时，需要初始值。这里与Java不同。


##### 数据类型
- Scala 与 Java 有着相同的数据类型，在Scala中数据类型都是对象，也就是说Scala中没有Java中的原生类型
- Scala数据类型分为两大类，他俩都是对象
  - AnyVal （值类型）
  - AnyRef  (引用类型)
- 相对于java的类型系统，Scala更复杂，也正是这复杂多变的类型系统才让面向对象和函数式完美的融合在了一起


Scala数据类型
Any <-> Nothing
- AnyVal
  - Unit
  - StringOps
  - Char
  - Boolean
  - Byte
  - Short
  - Int
  - Long
  - Float
  - Double
- AnyRef <-> Null <- Nothing
  - Scala collections
  - all java classes
  - Other Scala classes


小结：
- 在Scala中有一个根类型Any，他是所有类的父类
- Scala中一切皆为对象，分为两大类 AnyVal(值类型)，AnyRef(引用类型)，它们都是Any的子类
- Null 是scala的特别类型，它只有一个值 null，它是是一个bottom class，是所有AnyRef的类型的子类
- Nothing 类也是 bottom class， 它是所有类的子类，在开发中通常可以将Nothing类型的值返回给任意变量或者函数，是抛异常时使用较多。
- 在Scala中仍然遵守，低精度向高精度自动转换（implicit conversion 隐式转换）


##### 布尔类型
1. 在Scala中，boolean类型只能取true 或 false。
2. boolean类型占1个字节。

##### Scala中的特殊类型

Unit、Null和Nothing

| 类型      |                                                       说明                                                       |
|:--------|:--------------------------------------------------------------------------------------------------------------:|
| Unit    |                             表示无值，和其他语言中的void等同。用作不返回任何结果的方法的结果类型。Unit只有一个实例值，写成()                              |
| Null    |                                             null,Null类型只有一个实例值null                                             |
| Nothing | Nothing类型在Scala的类层级最低端；它是任何类型的子类型。当一个函数，我们确定没有正常的返回值，可以用Nothing来指定返回类型。这样有一个好处，就是我们可以把返回的值（异常）赋给其它的函数或者变量（兼容性）<br/> |


1. Null 类型只有一个实例对象，null，类似于java中的null引用。null可以赋值给任意的 **引用类型(AnyRef)**, 但是不能复制给**值类型(AnyVal; 比如：Int,Float,Char,Boolean,Long 等等)**
2. Nothing，可以作为没有正常返回值的方法的返回类型，非常只管的告诉你这个方法不会正常返回，而且由于Nothing是其他任意类型的子类型，他还能跟要求返回值的方法兼容。简单说，Nothing主要用来抛异常用的。

##### 强制类型转换
1. 当进行数据的从 大 --> 小， 就需要强制类型转换
2. 强转符号只针对最近的操作数有效，往往会使用小括号提升优先级
3. Char类型可以保存Int的常量值，但不能保存Int的变量值，需要强转
4. Byte和Short类型在进行运算时，当做Int类型处理

# 第五章： 函数式编程（基础）

本章内容：
- 函数式编程基础
  - 函数定义/声明
  - 函数运行机制
  - *** 递归 [马丁强烈推荐使用递归来解决问题]
    - 递归是算法基础，如 邮差问题，最短路径，背包问题，迷宫问题回溯，
  - 过程
  - 惰性函数和异常
- 函数式编程高级
  - 值函数（函数字面量）
  - 高阶函数
  - 闭包
  - 应用函数
  - 柯里化函数，抽象控制。。。


##### 需要明确的概念
在Scala中需明确方法、函数、函数式编程和面向对象编程：
- 在Scala中，方法和函数几乎可以等同（比如它们的定义、使用、运行机制都一样），只是函数的使用更加灵活（方法转函数）
- 函数式编程是从编程范式的角度来谈的，可以这样理解：函数式编程把函数当做一等公民，充分利用函数、支持函数的多种使用方式
  - 比如：在Scala中函数像变量一样，即可以当做函数的参数使用，也可以将函数赋值给一个变量，函数的创建不依赖类或对象，而在Java中，函数的创建则要依赖于类或者接口
- 面相对象编程是以对象为基础的编程方式
- 在Scala中函数式编程和面向对象编程融合在了一起
- 函数式编程介绍
  - 函数式编程是一种编程范式属于”结构化编程“的一种，主要思想是把运算过程尽量写成一些列嵌套的函数调用
  - 函数式编程中，将函数也当做数据类型，因此可以接收函数当做输入和输出

##### 递归
递归：是一种解决复杂问题的方法
1. 将一个复杂问题拆解成多个解决方法一致的小问题，从而简化问题
2. 定义一个解决小问题的方法，然后在这个方法内再去嵌套调用自身方法
3. 定义方法时需要注意：
3.1 明确递归调用方法的结束条件，不然会无限递归
3.2 递归不能使用类型推导，必须指定返回的数据类型
4. 运行机制：
4.1 将方法按照递归调用条件依序压入栈中去执行方法

##### 过程
将函数的返回类型为Unit的函数称之为过程(Procedure)，如果明确函数没有返回值，那么等号可以省略

函数递归需要遵守的重要原则：
1. 执行一个函数时，就创建一个新的受保护的独立空间（stack）
2. 函数的局部变量时独立的，不会互相影响
3. 递归必须向退出递归的条件逼近，否则就是无限递归
4. 当一个函数执行完毕，或者遇到return，就会返回，遵守谁调用就把结果返回给谁。


##### 惰性函数

惰性计算（尽可能延迟表达式求值）是许多函数式编程语言的特性。惰性集合在需要时提供其元素，无需预先计算它们，这带来了一些好处。首先，可以将耗时计算推迟到
绝对需要的时候。其次，可以创造无限个集合，只要它们继续收到请求，就会继续提供元素。函数的惰性使用能够得到更搞笑的代码。Java并没有为惰性提供原生支持，但Scala提供了

注意事项：
> 1. lazy 不能修饰 var 类型的变量
> 2. 不单是在调用函数时，加了lazy会导致函数的执行被退出，在声明一个变量时，如果加了lazy，那么变量值的分配也会被推迟

##### 异常处理

Scala异常处理小结：
1. > 我们将可以代码封装在try中。在try块之后使用了catch处理程序来捕获异常。如果发生任何异常，catch处理程序将它处理，程序将不会异常终止。
2. > Scala的异常的工作机制和Java一样，但是Scala没有 "checked(编译期)" 异常，即Scala没有编译异常这个概念，异常都是在运行时捕获处理。
3. > 用 `throw` 关键字，抛出一个异常对象。 所有异常都是Throwable的子类型。throw表达式没有类型的，就是Nothing，因为Nothing是所有类型的子类型，所以 throw 表达式可以唵在任何需要类型的地方
4. > 在Scala里，借用了模式匹配的结果来做异常工作，因此，在catch的代码里，是一系列case子句来匹配异常。
5. > 异常捕获的机制与其他语言一样，如果有异常发生，catch子句是按次序捕获的。因此，在catch子句中，越具体的异常越要靠前，越普遍的异常越靠后，如果把越普遍的异常写在前，把具体异常写在后，也不会报错. !但是，这是非常不好的编码风格。
6. > finally 子句用于执行不管时正常处理还是异常发生时都需要执行的步骤，一般用于对象的清理工作和Java一样
7. > Scala提供了throws关键字来声明异常。可以使用方法定义声明异常。它向调用者函数提供了此方法可能引发的异常信息。它有助于调用函数处理并将该代码包含在try-catch中以避免程序异常终止
```scala 
@throws(classOf[NumberFormatException]) // 等同于 NumberFormatException.class
def test2(): Unit = {
    println("提示可能抛出NumberFormatException异常")
}
```

# 第六章： 面相对象编程（基础）

Scala语言面向对象
1. Java是面向对象的，由于历史原因，Java中还存在着非面向对象的内容如：int, null, 和 静态方法 等。
2. Scala是纯粹的面向对象，真正做到万物皆对象。

##### 构造器

和Java一样，Scala构造器也需要调用构造方法，并且可以由任意多个构造器

Scala构造器有两种：主构造器 和 辅助构造器

```scala 
class 类名(形参列表){ // 主构造器
  
  def this(形参列表) {} // 辅助构造器
  
  def this(形参列表) {} // 辅助构造器
}
```

构造器注意事项和细节：
1. Scala构造器作用是完成对新对象的初始化，构造器没有返回值。
2. 主构造器的声明直接放置于类名之后
3. 主构造器会执行类定义中的所有语句，这里可以体会得到Scala函数式编程和面向对象编程的融合，即：构造器也是方法，传参和使用方法和函数没有区别
4. 如果主构造器无参数，小括号可以省略，构建对象时调用的构造方法小括号可以省略
5. 辅助构造器名称为this，多个辅助构造器通过不同的形参列表进行区分，底层类似于java的构造器重载。
6. 如果想让主构造器变成私有的，可以在 () 之前加上private，这样用户只能通过辅助构造器来构造对象
7. 辅助构造器的声明不能和主构造器的声明一致，会发生错误

构造器参数
1. Scala类的主构造器函数的形参未用任何修饰符修饰，那么这个参数时局部变量
2. 如果参数使用val关键字声明，那么Scala会将参数作为类的私有的只读属性使用
3. 如果参数使用var关键字声明，那么Scala会将参数作为类的成员属性使用，并会提供属性对应的xxx()类似getter setter方法，即这时的成员属性是私有的，但是可以读写

```scala
// 如果主构造器的形参没有使用任何修饰符，
// 那么这个参数就是一个局部变量，范围就是主构造器中。
class ConstructorParamsDemo01(name: String) {

}

// 如果主构造器的形参用val修饰
// 那么这个形参会成为这个类的只读的私有属性 即 private final String name
// 实例化后可以直接访问这个属性
class ConstructorParamsDemo02(val name: String) {

}


// 如果主构造器的形参用var修饰
// 那么这个参数就是一个private 可读写的属性
class ConstructorParamsDemo03(var name: String) {

}

// BeanProperty 会自动生成 类似Java 的 Getter Setter 方法
class Car(
  @BeanProperty val car: String,
  @BeanProperty val color: String
) { }
```

##### Scala 创建对象的流程
1. 加载类的信息（属性信息，方法信息）
2. 在内存中（堆）开辟空间
3. 使用父类的构造器（主和辅助）进行初始化
4. 使用主构造器对属性进行初始化
5. 使用辅助构造器对属性进行初始化
6. 将开辟的对象地址赋值给xxx这个常量/变量进行引用

# 第七章：Scala 面向对象中级

##### Scala 包

Scala的包比Java更加强大且相对复杂一些

包的注意事项和使用细节:
1. 包也可以像嵌套类那样嵌套使用，这样做的好处是，可以在同一个文件中将 class object trait 创建在不同包中，这样非常灵活
2. 作用域原则：可以直接向上访问。即：Scala中子包可以直接访问父包中的内容。在子包和父包类重名时，默认采用就近原则，如果希望指定某个类，则带上包名即可
3. 父包要访问子包内容时，需要import对应的类
4. 可以在同一个.scala文件中，声明多个并列的package

##### 包对象
基本介绍：包可以包含类、对象和特质，但不能包含函数或变量的定义。这是JVM的局限。为了弥补这一点不足，Scala提供了包对象的概念来解决这个问题

注意事项：
1. 每个包都可以有一个包对象。你需要在父包中定义它
2. 包对象名称需要和包名一致，一般用来对包的功能补充

##### 包的可见性
1. 当属性访问权限为默认时，底层看是private的，但是提供了 xxx_$eq() 类似getter setter方法，因此从使用效果看任何地方都可以访问
2. 当方法访问权限为默认时，默认为public访问权限
3. private为私有权限，只在类的内部和伴生对象中使用
4. protected 在Scala中比Java要严格，只能子类访问，同包无法访问
5. 在Scala中没有public关键字，即不能用public显示的修饰属性和方法
6. 包访问权限（表示属性有了限制。同时包也有了限制），这点和Java不同。
```scala
package visit

class TestPerson {
    // 这是限制了只有类内部和伴生对象中访问
    private val name:String = "zhang san"
    
    // private[visit] : 此时 age 属性仍然是私有的，但是在visit包下也可以使用这个属性 
    // 相当于扩大了访问烦我
    private[visit] val age:Int = 10 
    
}

class Test {
  def main(args: Array[String]): Unit = {
    val person: TestPerson = new TestPerson
    println(person.age)
  }
}
```

##### 包的引入

1. 在Scala中，import语句可以出现在任何地方，并不仅限于文件顶部。import语句的作用一致眼神到包含该语句块的末尾。这种语法的好处是：在需要时引入，缩小import的作用范围，提高效率
2. 如果不想要某个包中的全部类，而是其中几个类，可以采用选择器 
```scala
import scala.collection.mutable.{HashMap,HashSet}
```
3. 如果引入多个包含有相同的类，那么可以将不需要的类进行重命名进行分区

```scala
import java.util.{HashMap => JavaHashMap}
import scala.collection.mutable._

var map = new HashMap() // scala HashMap
var m1 = new JavaHashMap() // java HashMap
```
4. 如果某个冲突的类根本就不会用到，那么可以直接隐藏掉该类
```scala
import java.util.{ HashMap => _,_} // 含义为 引入java.util包的所有类，但忽略掉hashMap 这个类

var map = new HashMap() // scala HashMap ,而且idea也不会提示有java HashMap
```


##### Scala 抽象
把一类事物的共同属性和方法提取出来，形成一个屋里模型。这种研究问题的方法称为抽象

举例：不管是工行还是Chase的银行账号，都应该有 [账号，余额，...] 等属性 以及 [存款，取款，...] 等方法


##### Scala 继承

当修改父类时，对应的子类就会继承想用的方法和属性，从而提高了扩展性和维护性。

Scala中超类的构造
1. 类有一个主构造器和任意数量的辅助构造器，而每个辅助构造器都要先调用主构造器
2. 只有主构造器可以调用父类构造器。辅助构造器不能直接调用父类的构造器。即不能 super(params)

覆写字段：
1. 在Scala中，子类改写父类的字段，称之为覆写字段。需要使用override修饰
2. def 只能覆写另一个def
3. val 只能覆写另一个val 或不带参数的def
4. var 只能重写另一个抽象的var属性 【抽象属性：声明未初始化的变量就是抽象的属性，抽象属性在抽象类】
   - 一个属性没有初始化，那么这个属性就是抽象属性
   - 抽象属性在编译成字节码文件时，属性并不会声明，但是会自动生成抽象方法，所以类必须声明为抽象类
   - 如果是覆写一个父类的抽象属性，那么override关键字可以省略（因为父类的抽象属性，生成的是抽象方法，因此就不涉及到方法的重写概念，因此override可以省略）

##### 抽象类
在Scala中通过abstract关键字标记不能被实例化的类。 方法 `不用标记` abstract，只要省掉方法体即可。抽象类可以拥有抽象字段，抽象字段就是没有初始值的字段。

抽象类的价值更多是在于设计层面，是设计者设计好后，让子类继承并实现抽象。

使用细节：
1. 抽象类不能实例化
2. 抽象类不一定包含abstract方法。也就是说，抽象类可以没有abstract方法
3. 一旦包含了抽象方法或抽象属性，则这个类必须声明abstract
4. 抽象方法不能有主题，不允许使用abstract修饰
5. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法和抽象属性，除非它自己也声明为abstract类
6. 抽象方法和抽象属性不能使用private、final来修饰，因为这些关键字是和重写/实现相违背的
7. 抽象类中可以实现的方法
8. 子类重写抽象方法不需要override，但是写上也不会报错





















