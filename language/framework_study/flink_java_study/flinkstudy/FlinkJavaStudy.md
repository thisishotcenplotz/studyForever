# 第一章：Flink概述

##### Flink 特点：

1. 流批统一
2. 性能卓越：高吞吐 低延迟
3. 规模计算： 支持水平扩展，支持超大状态与增量检查点机制
4. 生态兼容：支持K8s继承，支持单机模式
5. 高容错：故障自动重试、一致性检查点。

##### Flink 

Flink 核心目标是 “数据流上的有状态计算” (Stateful Computation over Data Streams).

Apache Flink 是一个分布式处理引擎，用于对无界和有界数据流进行有状态计算。

##### 有界流和无界流

无界流：
- 有定义流的开始，但没有定义流的结束；
- 它们会无休止的生产数据；
- 无界流的数据必须持续处理，即数据被摄取后需要立即处理。我们不能等到所有数据到达再处理，因为输入是无限的。

有界流：
- 有定义流的开始，也定义流的结束。
- 有界流可以在摄取所有数据后再进行计算；
- 有界流所有数据可以被排序，所以并不需要有序摄取。
- 有界流处理通常被称为批处理。

##### 有状态流处理

把流处理需要的额外数据保存成一个“状态”，然后针对这条数据进行处理，并且更新状态。这就是所谓的“有状态的流处理”

这个状态可以存放在内存中，也可以存放在分布式系统中。

##### Flink 特点

- 高吞吐低延迟: 每秒处理数百万个事件，毫秒级延迟。
- 结果的准确性。Flink 提供了事件事件(event-time) 和 处理时间(processing-time)语义。对于乱序事件流，事件时间语义仍然提供一致且准确的结果。
- 精确一次(exactly-once) 的状态一致性保证。
- 可以连接到最常用的存储系统，如Kafka、Hive、JDBC、HDFS、Redis等。
- 高可用。本身高可用的设置，加上与K8S、Yarn、Mesos的紧密集成，再加上从故障中快速回复和动态扩展任务的能力，Flink能做到以极少的停机事件7 * 24 全天候运行。


##### Flink 分层API

有状态流处理（底层API） -> DataStream/DataSetAPI (核心API) -> Table API （声明式领域专用语言） -> SQL (最高层语言) 


# 第二章：Flink快速上手

一个简单的word count

# 第三章: 集群部署

Flink 集群几个重要组件:

1. Client: 代码由client获取并转换,之后提交给jobManager
2. JobManager: 就是Flink集群里的"管事人",对作业进行中央调度管理;而它获取到要执行的作业后,就会进一步处理转换,然后分发给TaskManager.
3. TaskManager: 就是真正"干活的人"人,数据的处理操作都是它们来做的.

##### 部署模式

1. 会话模式（Session）：会话模式最符合常规思维。需要先启动一个集群，保持一个会话，在这个会话中通过客户端提交作业。集群启动时所有资源就都已经确定，所以所有提交的作业会竞争集群中的资源。
2. 单作业模式 （Per-Job Model）：会话 模式因为资源共享会导致很多问题，所以为了更好地隔离资源，我们可以考虑为每个提交的作业启动一个集群，这就是所谓的单作业模式。
作业完成后，集群就会关闭，所有资源也会释放。
这些特性使得单作业模式在生产环境运行更加稳定，所以是实际引用的首选模式。
需要注意的是，Flink本身无法直接这样运行，所以单作业模式一般需要借助一些资源管理框架来启动集群，比如YARN 或 K8S
3. 应用模式 （Application Mode）：前面两种模式下，应用代码都是在客户端上执行，然后由客户端提交给JobManager的。
但是这种方式客户端需要占用大量网络贷款，去下载依赖和把二进制的数据发送给JobManager；加上很多情况下我们提交作业用的是同一个客户端，就会加重客户端所在节点的资源消耗。
所以解决办法就是，我们不要客户端了，直接把应用提交到JobManager上运行。而这也就代表着，我们需要为每一个提交的应用单独启动一个JobManager，也就是创建一个集群。这个JobManager只为执行这一个应用而存在，
执行结束之后JobManager也就关闭了，这就是所谓的应用模式。

这三种模式的主要区别于，集群的声明周期以及资源的分配方式：以及应用的main方法到底在哪里执行 -- Client 还是 JobManager

##### Flink 运行时架构

客户端 <-> JobManager -> TaskManager

1. JobManager: 是一个FLink集群中任务管理和核心的调度，是控制应用执行的主进程。也就是说，每个应用都应该被唯一的JobManager所控制执行。
JobManager 又包含了3个不同的组件：
    - JobMaster： 是JobManager中最核心的组件，负责处理单独的job。所以JobMaster和具体的Job是一一对应的，多个Job可以同时运行在一个Flink集群中，每个Job都有一个自己的JobMaster。
                  提交作业时，JobMaster会先接收到要执行的应用。JobMaster会把JobGraph转换成一个屋里层面的数据流图，这个图被叫做ExecutionGraph,它包含了所有可以并发执行的任务。JobMaster会向资源管理器发出请求，申请执行任务必要的资源。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的TaskManager上。而在运行过程中，JobMaster会负责所有需要中央协调的操作，比如检查点协调等。
    - ResourceManager：主要负责资源的分配和管理，在Flink集群中只有一个所谓的资源，只要指TaskManager的Slot。任务槽就是Flink急群众的资源调配单元，包含了机器用来执行计算的一组CPU和内存。每个任务Task都要分配到一个Slot上来执行。
    - Dispatcher：分发器抓哟负责提供一个REST接口，用来提交应用，并且负责为每一个提交的作业启动一个新的JobMaster组件。Dispatcher也会启动一个WebUI，用来方便地展示和监控作业执行的信息。Dispatcher在架构中并不是必需的，在不同的模式下可能会被忽略掉。
2. TaskManager：是Flink中的工作进程，数据的具体计算就是它来做。Flink集群中必须至少有一个TaskManager；每个TaskManager都包含了一定数量的Slot。Slot是自愿调度的最小单位，slot的数量限制了TaskManager能够并行处理的任务数量。启动之后，TaskManager会向资源管理器注册它的Slots；收到资源管理器的指令后，TaskManager就会将一个或多个slot提供给JobMaster调用，JobMaster就会分配任务来执行。在执行过程中，TaskManager可以缓冲数据，还可以跟其他运行同一TaskManager交换数据


##### Parallelism

1. 并行子任务和并行度： 
当要处理的数据量非常大时，我们可以把一个算子操作，赋值多份到多个节点，数据来了之后就可以到其中任意一个执行。这样依赖，一个算子任务就被拆分成了多个并行的子任务，再将他们分发到不同节点
实现真正的并行计算。
在Flink执行过程中，每一个算子都包含了一个或多个子任务，这些子任务在不同的线程、不同的物理机或不同的容器中完全独立的执行。

##### Operator Chain 算子链

一个数据流在算子之间传输的形式可以是 one-to-one 的 forward 模式， 也可以是打乱的redistribution模式，具体哪一种形式，取决于算子的类型

1. one to one:

这种模式下，数据流维护着分区以及元素的顺序。比如source 和 map 算子，source  算子读取数据之后，可以直接发送给map算子处理，它们之间不需要重分区，也不需要调整数据的顺序。这就
意味着map算子的子任务，看到的元素个数和顺序跟source算子的子任务产生的完全一样，保证这一对一的关系。 map、filter、flatMap等算子都是这种 one-to-one 的对应关系。这种关系类似于Spark中的窄依赖。

2. Redistribution

在这种模式下，数据流的分区会发生改变。比如图中的map和后面的keyBy/window 算子之间，以及keyBy/window算子和Sink算子之间，都是这样的关系。
没一个算子的子任务，会根据数据传输的策略，把数据发送到不同的下游目标任务。这种传输方式都会引起重分区过程，类似于Spark中的shuffle。


##### Task Slots

1. 任务槽： Flink 中每一个TaskManager都是一个JVM进程，它可以启动多个独立的线程，来并行执行多个子任务；
很显然，TaskManager的计算资源是有限的，并行的任务越多，每个线程的资源就会越少。那么一个TaskManager到底能并行处理多少个任务呢？为了控制并发量，我们需要在TaskManager上对每个任务运行时所占用的资源做出明确的划分，这就是所谓的task slog。
每个task slot 其实表示了TaskManager拥有计算资源的一个固定大小的子集。这些资源就是用来独立执行一个子任务的。
假如一个TaskManager有三个Slot，那么它会将管理的内存平均分成三份，每个slot独占一份。这样一来，我们在slot上执行一个子任务时，相当于划定了一块专用内存，就不需要跟其他作业去竞争资源了。所以如果有2个TaskManager，就可以并行跑5个子任务。
2. 任务对slot的共享：
在同一个作业中，不同任务节点的并行度子任务就可以放到同一个slot上执行。默认情况下，FLink是允许子任务共享slot的。如果我们保持sink任务并行度为1不变，
而作业提交时设置全局并行度为6，那么前两个任务节点就会各自有6个并行子任务，整个流处理程序则有13个子任务。只要属于同一个作业，那么对于不同任务节点的并行子任务，就可以放到同一个slot上执行。所以对于第一个任务节点 source -> map,
它的6个并行子任务必须分到6个不同的slot上，而第二个任务节点keyBy/window/apply的并行子任务却可以和第一个任务节点共享slot。
3. 任务槽和并行度都是跟程序并行执行有关，但两者是完全不同的概念。简单来说任务槽是静态的概念，是只TaskManager具有的并发执行能力，可以通过参数taskmanager.numberOfTaskSlot进行配置；
而并行度是动态概念，也就是TaskManager运行程序时实际使用的并发能力，可以通过参数parallelism.default进行配置。

# 第五章：DataStream API
DataStream API 是 Flink的核心层API。一个Flink程序，其实就是对DataStream的各种转换。具体来说，代码基本是由 Environment ->  Source ->  Transformation -> Sink -> execute
这个几个部分组成

# 第六章：窗口

在批处理统计中，我们可以等待一批数据到齐后，统一处理。但是在实时处理统计中，我们是来一条处理一条，那么我们怎么统计最近一段时间内的数据呢？这就要引入“窗口的概念”。
所谓的窗口，一般就是划定的时间范围，也就是“时间窗”；对在这范围内的数据进行处理，就是所谓的窗口计算。所以窗口和时间往往是分不开的。也就是将无限无界的数据切割成有限的"数据块"，进行处理。

可以这样理解： 在Flink中，窗口就是一个桶，它可以把流切割成有限大小的多个“桶”;每个数据都会分发到对应的桶中，当到达窗口结束时间，就对每个桶中收集的数据进行计算处理。

##### 窗口按驱动类型分类

1. 时间窗口：时间窗口以时间来定义窗口的开始和结束，所以截取出的就是某一个事件段的数据。到达结束时间时，窗口不再收集数据，触发计算输出结果，并将窗口关闭销毁。所以基本思路就是”定点发车“。
2. 计数窗口基于元素的个数来截取事件，到达固定的个数时就触发计算并关闭窗口。每个窗口截取数据的个数，就是窗口的大小。基本思路就是”人齐发车“。

##### 窗口按分配数据规则分类
1. 滚动窗口(Tumbling Windows): 滚动窗口有固定的大小、是一种对数据进行”均匀切片“的划分方式。窗口之间没有重叠，也不会有间隔，是”首尾相接“的状态。这是最简单的窗口形式，每个数据都会被分配到一个窗口，而且只会属于一个窗口。
2. 滑动窗口(Sliding Windows): 滑动窗口的大小也是固定的。但是窗口之间并不是首尾相接的。而是可以错开一定位置的。定义滑动窗口需要定义窗口大小和滑动步长。滑动步长就代表了窗口的计算频率。
当滑动步长小于窗口大小，滑动窗口就会出现重叠，这时数据也可能被同时分配到多个窗口中。而具体的个数就由窗口大小和滑动步长的比值来决定。滚动窗口可以看做特殊的滑动窗口（size=slide）。
滑动窗口适合计算结果更新频率非常高的场景。
3. 会话窗口(Session Windows): 基于session里对数据进行分组。会话窗口只能基于时间来定义。会话窗口中，最重要的参数就是会话超时时间，也就是两个会话窗口之间最小的距离。
如果相邻的两个数据到来的间隔（gap）小于制指定的size，那说明还在保持会话，它们就属于同一个窗口，如果gap大于size，那么新来的属于就属于新的窗口，而前一个窗口就应该关闭了。
会话窗口的长度不固定，开始和结束时间也不确定，各个分区之间窗口没有任何关联。会话窗口之间一定不会重叠，而且会留有至少size的间隔。
在一些类似保持会话的场景下，可以使用会话窗口进行数据的处理统计。
4. 全局窗口(Global Windows): 这种窗口全局有效，会把相同key的所有数据都分配到一个窗口中。这种窗口没有结束的时候，默认是不会触发计算的。如果希望它能对数据进行计算处理，还需要自定义触发器(Trigger).
全局窗口没有结束时间点，所以一般希望做更加灵活的窗口处理时自定义使用。Flink中的计算窗口(Count Window) 底层就是用全局窗口实现的。

