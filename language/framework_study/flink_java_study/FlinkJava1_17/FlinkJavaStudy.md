# 第一章：Flink概述

##### Flink 特点：

1. 流批统一
2. 性能卓越：高吞吐 低延迟
3. 规模计算： 支持水平扩展，支持超大状态与增量检查点机制
4. 生态兼容：支持K8s继承，支持单机模式
5. 高容错：故障自动重试、一致性检查点。

##### Flink 

Flink 核心目标是 “数据流上的有状态计算” (Stateful Computation over Data Streams).

Apache Flink 是一个分布式处理引擎，用于对无界和有界数据流进行有状态计算。

##### 有界流和无界流

无界流：
- 有定义流的开始，但没有定义流的结束；
- 它们会无休止的生产数据；
- 无界流的数据必须持续处理，即数据被摄取后需要立即处理。我们不能等到所有数据到达再处理，因为输入是无限的。

有界流：
- 有定义流的开始，也定义流的结束。
- 有界流可以在摄取所有数据后再进行计算；
- 有界流所有数据可以被排序，所以并不需要有序摄取。
- 有界流处理通常被称为批处理。

##### 有状态流处理

把流处理需要的额外数据保存成一个“状态”，然后针对这条数据进行处理，并且更新状态。这就是所谓的“有状态的流处理”

这个状态可以存放在内存中，也可以存放在分布式系统中。

##### Flink 特点

- 高吞吐低延迟: 每秒处理数百万个事件，毫秒级延迟。
- 结果的准确性。Flink 提供了事件事件(event-time) 和 处理时间(processing-time)语义。对于乱序事件流，事件时间语义仍然提供一致且准确的结果。
- 精确一次(exactly-once) 的状态一致性保证。
- 可以连接到最常用的存储系统，如Kafka、Hive、JDBC、HDFS、Redis等。
- 高可用。本身高可用的设置，加上与K8S、Yarn、Mesos的紧密集成，再加上从故障中快速回复和动态扩展任务的能力，Flink能做到以极少的停机事件7 * 24 全天候运行。


##### Flink 分层API

有状态流处理（底层API） -> DataStream/DataSetAPI (核心API) -> Table API （声明式领域专用语言） -> SQL (最高层语言) 


# 第二章：Flink快速上手

一个简单的word count

# 第三章: 集群部署

Flink 集群几个重要组件:

1. Client: 代码由client获取并转换,之后提交给jobManager
2. JobManager: 就是Flink集群里的"管事人",对作业进行中央调度管理;而它获取到要执行的作业后,就会进一步处理转换,然后分发给TaskManager.
3. TaskManager: 就是真正"干活的人"人,数据的处理操作都是它们来做的.

##### 部署模式

1. 会话模式（Session）：会话模式最符合常规思维。需要先启动一个集群，保持一个会话，在这个会话中通过客户端提交作业。集群启动时所有资源就都已经确定，所以所有提交的作业会竞争集群中的资源。
2. 单作业模式 （Per-Job Model）：会话 模式因为资源共享会导致很多问题，所以为了更好地隔离资源，我们可以考虑为每个提交的作业启动一个集群，这就是所谓的单作业模式。
作业完成后，集群就会关闭，所有资源也会释放。
这些特性使得单作业模式在生产环境运行更加稳定，所以是实际引用的首选模式。
需要注意的是，Flink本身无法直接这样运行，所以单作业模式一般需要借助一些资源管理框架来启动集群，比如YARN 或 K8S
3. 应用模式 （Application Mode）：前面两种模式下，应用代码都是在客户端上执行，然后由客户端提交给JobManager的。
但是这种方式客户端需要占用大量网络贷款，去下载依赖和把二进制的数据发送给JobManager；加上很多情况下我们提交作业用的是同一个客户端，就会加重客户端所在节点的资源消耗。
所以解决办法就是，我们不要客户端了，直接把应用提交到JobManager上运行。而这也就代表着，我们需要为每一个提交的应用单独启动一个JobManager，也就是创建一个集群。这个JobManager只为执行这一个应用而存在，
执行结束之后JobManager也就关闭了，这就是所谓的应用模式。

这三种模式的主要区别于，集群的声明周期以及资源的分配方式：以及应用的main方法到底在哪里执行 -- Client 还是 JobManager

