# 内容介绍

Java技术体系导图:

- java基础
    - 第一阶段：建立编程思想
        - java 概述
            - 如何快速学习java技术
            - java历史
            - java特点
            - java运算机制
            - JDK
            - 转义字符
            - java开发规范
            - java API
        - 变量
            - 数据类型
            - 变量基本使用
            - 数据类型转换
        - 运算符
            - 运算符介绍
            - 算数运算符
            - 关系运算符
            - 逻辑运算符
            - 赋值运算符
            - 三元运算符
            - 优先级
            - 二进制 *
            - 位运算符
        - 控制结构
            - 顺序
            - 分支
            - 循环
            - break
            - continue
            - return
        - 数组、排序和查找
            - 数组 *
            - 排序
            - 查找
        - 面相对象编程（基础）
            - 类与对象
            - 成员方法
            - 成员方法传参机制
            - overload
            - 可变参数
            - 作用域
            - 构造器
            - this
        - 面相对象编程（中级）
            - 包
            - 访问修饰符
            - 封装
            - 继承
            - 多态
            - Super
            - overwrite
            - Object类详解
            - 断点调试
        - 项目&学以致用-编程之乐
            - 零钱通
            - 房屋出租系统
    - 第二阶段：提升编程能力
        - 面相对象编程（高级）
            - 类变量和类方法
            - 理解main方法语法
            - 代码块
            - 单例设计模式
            - final关键字
            - 抽象类
            - 接口
            - 内部类
        - 枚举和注解
            - 自定义类实现枚举
            - enum关键字实现枚举
            - JDK内置的基本注解类型
            - 元注解：对注解进行注解
        - Exception
            - 异常的概念
            - 异常体系图
            - 常见的异常
            - 异常处理
            - 自定义异常
            - throw和throws的对比
        - 常用类
            - 包装类
            - String
            - StringBuffer
            - StringBuilder
            - Math
            - Date、Calendar、LocalDate
            - System
            - Arrays
            - BigInteger、BigDecimal
        - 集合
            - 集合框架体系
            - Collection
                - List
                    - ArrayList
                    - LinkedList
                    - Vector
                - Set
                    - HashSet
                    - LinkedHashSet
                    - TreeSet
            - Map
                - HashMap
                - Hashtable
                - LinkedHashMap
                - TreeMap
                - Properties
            - Collections
        - 泛型
            - 泛型语法
            - 自定义泛型
                - 泛型类
                - 泛型接口
                - 泛型方法
            - 泛型继承和通配符
        - 线程（基础）
            - 线程介绍
            - 线程使用
                - 继承Thread
                - 实现Runnable
            - 线程方法
            - 线程生命周期
            - Synchronized
            - 互斥锁
            - 死锁
        - IO流
            - 文件
            - IO流原理及流的分类
            - 节点流和处理流
            - 输入流
                - InputStream
                    - FileInputStream
                    - BufferedInputStream
                    - ObjectInputStream
                - Reader
                    - FileReader
                    - BufferedReader
                    - InputStreamReader
            - 输出流
                - OutputStream
                    - FileOutputStream
                    - BufferedOutputStream
                    - ObjectOutputStream
                - Write
                    - FileWriter
                    - BufferedWriter
                    - OutputStreamWriter
            - Properties类
        - 项目&学以致用-编程之乐
            - 坦克大战
    - 第三阶段：分析需求，代码实现能力
        - 网络编程
            - 网络基础
            - InetAddress
            - Socket
            - TCP编程
                - 字节流
                - 字符流
            - UDP编程
        - 反射
            - 反射机制
            - class类
            - 类的加载
            - 反射获取类的结构信息
                - Class
                - Field
                - Method
                - Constructor
                - 访问属性
                - 访问方法
        - mysql基础
            - mysql安装和配置
            - 数据库
            - 表
            - mysql数据类型
            - crud
            - 函数
            - 内连接
            - 外连接
            - 约束
            - 索引
            - 事务
        - JDBC和连接池
            - JDBC概述
            - JDBC快速入门
            - JDBC API
                - PreparedStatement
                - DriverManager
                - Statement
                - ResultSet
            - JDBCUtils
            - 事务
            - 批处理
            - 连接池
                - DataSource
                - DBCP
                - C3P0
                - Proxool
                - BoneCP
                - Druid
            - Apache DBUtils
            - DAO增删改查-BasicDAO
        - 正则表达式（非常实用）
            - 快速入门
            - 正则表达式基本语法
            - 三个常用类
                - Pattern
                - Matcher
                - PatternSyntaxException
            - 分组、捕获、反向引用
            - 元字符
                - 限定符
                - 选择匹配符
                - 分组组合和反向引用符
                - 特殊字符
                - 字符匹配符
                - 定位符
            - 应用实例
        - Java8 & 11 新特性
            - java8
                - lambda
                - 函数式接口
                - 接口静态方法
                - 接口默认方法
                - 方法引用
                - 构造器引用
                - Stream API
                - 并行流
                - 串行流
                - Optional
                - 新时间日期API
            - java11
                - 代码层面
                    - JShell
                    - 类型推断
                    - 集合增强API
                    - Stream 加强
                    - 新增字符串处理方法
                    - Optional 加强
                    - InputStream 增强API
                    - 标准Java异步HTTP客户端
                - 其他新特性
                    - 简化的编译运行
                    - 支持 Unicode10
                    - Epsilon垃圾回收器
                    - ZGC
                    - JFR
                    - 支持linux容器
                    - 支持G1上的并行完全垃圾收集
                    - 增加加密算法，代替RC4
                    - 最新HTTPS安全协议TLS1.3
                    - 移除和废弃的内容
        - 项目&学以致用-编程之乐
            - 骑士周游问题（算法-优化）
            - 满汉楼
            - 多用户通信系统-推消息 私聊 发文件
- java高级
    - java多线程/高并发
    - 数据结构和算法
        - 数据结构
            - 数组（系数数组）
            - 队列
            - 栈
            - 链表
            - 树
            - 散列
            - 堆
            - 图
        - 算法
            - 排序（8种）
            - 查找
            - 分治
            - 动态规划（背包问题）
            - 回溯（骑士周游问题）
            - 贪心算法
            - KMP
            - Prim
            - Kruskal
            - floyd-最短路径
            - 迪杰斯拉特-最短路径
    - 设计模式（23种）
    - JVM
      - JVM体系
      - 类加载过程/机制
      - 双亲委派机制/沙箱安全机制
      - JMM(java内存模式)
      - 字节码执行的过程/机制
      - GC（垃圾回收算法）
      - JVM性能监控和故障定位
      - JVM调优
- javaWEB
- 主流的框架和项目管理
    - Linux
    - Nginx（做反向代理和web服务）
    - SSM
        - Spring
        - SpringMVC
        - MyBatis
    - 项目管理
    - 数据库
    - 其他框架
- 分布式 微服务 并行架构
- DevOps，自动化部分管理项目，解决CI/CD
- 大数据技术
- 项目
- 高频面试题
- 底层源码/内核研究
  - 计算机网络
  - 操作系统
  - 编译原理
  - 离散
  - 数值分析
  - 计算机组成原理
  - 汇编语言

# Java开发场景

举例1-SSM：

- Spring（轻量级的容器框架）
- SpringMVC（分层的web开发框架）
- MyBatis（持久化框架）

举例2-Android核心代码

举例3-大数据Hadoop

# 第二章 Java语言概述

##### Java 历史

Java 诞生小历史

- 1990年 sun公司启动绿色计划
- 1992年 创建oak语言 -> java
- 1994年 gosling 参加硅谷大会 演示java功能，震惊世界
- 1995年 sun正式发布java第一个版本
- 2009年，甲骨文宣布收购sun。2011，发布java7
- 2017年9月发布java8
- 2018年9月发布java11

Java技术体系平台

- JavaSE
    - 支持面相桌面级应用的java平台，提供了完整的java核心API
- JavaEE
    - 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如Servlet，Jsp等，主要针对web应用程序开发
- JavaME
    - 支持java程序运行在移动端上的平台，对Java API有所精简，并加入针对移动端的支持

##### Java 特点

1. Java语言是面向对象的
2. Java语言是健壮的。Java的强类型机制、异常处理、垃圾回收等特性是Java健壮性的重要保障
3. Java是跨平台的(一次编译，到处运行)。
4. Java语言是解释型的。

##### Java 运行机制及运行流程

- Java 核心机制---java虚拟机
    - JVM是一个虚拟的计算机，具有几零几并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK中。
    - 对于不同的平台，you不同的虚拟机。
    - Java虚拟机机制屏蔽了底层运行平台的区别，实现了"一次编译，到处运行"

什么是JDK，JRE

1. JDK的全称是 java development kit。<br> JDK = JRE + Java的开发工具（java,javac,javadoc,javap等）
2. JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装JDK，就不用单独再安装JRE了

JRE基本介绍

1. JRE （Java Runtime Environment）<br> JRE = JVM + Java核心的类库
2. 包括java虚拟机和java程序所需要的核心类库等，如果向要运行一个开发好的java程序，计算机中只需要安装JRE即可。

JDK、JRE和JVM的关系

1. JDK = JRE + 开发工具集
2. JRE = JVM + Java SE 标准类库
3. JDK = JVM + Java SE 标准类库 + 开发工具集
4. 如果只想运行开发好的.class文件 只需要JRE即可

xxx.java --> java.class --> jvm(java.class)

##### Java 开发环境搭建

略。。。

##### Java 快速入门

什么事编译

1. 有了java源文件，通过编译器将其编译成为JVM可以识别的字节码文件。
2. 在该源文件目录下，通过javac编译工具对Hello.java 文件进行编译。
3. 如果程序没有错误，没有任何提示，但在当前目录下会出现一个Hello.class 文件，该文件称为字节码文件，也是可以执行的java程序。

什么是运行

1. 有了可执行的java程序，就是把class文件放到jvm里执行，
2. 通过运行工具java对字节码文件进行执行。

java程序开发注意事项

1. 对修改后的Hello.java源文件需要重新编译，生成新的class文件后，再进行执行，才能生效。
2. java源文件以.java为扩展名。源文件的基本组成部分是类(class)，如本类中的Hello类。
3. java应用程序的执行入口是main()方法。它有固定的书写格式：public static void main(String[] args) {...}
4. java语言严格区分大小写。
5. java方法由一条条的语句构成，每个语句以;结束。
6. 大括号都是成对出现的，缺一不可。
7. 一个源文件中最多只能有一个public类。其他类的个数不限
8. 如果源文件包含一个public类，则文件名必须按该类名命名。
9. 一个源文件中最多值能有一个public类。其他类的个数不限，也可以将main方法卸载非public类中，然后指定非public类，这样入口方法就是非public的main方法。

##### Java 转义字符

1. \t： 一个制表位，实现对齐的功能
2. \n: 换行符
3. \\: 一个\
4. \": 一个"
5. \': 一个'
6. \r: 一个回车

##### 初学java易犯的错误

1. 找不到文件
   <br>
   解决方法：源文件名不存在或者写错，或者当前路径错误
2. 主类名和文件名不一致
   <br>
   解决方案：声明为public的主类应与文件名一致，否则编译失败。
3. 缺少分号
   <br>
   解决方法：编译失败，注意错误出现的行数，再到原码中指定位置改错。

##### 注释介绍

注释：用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性；注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码区体现。

java中的注释类型：

1. 单行注释<br>
   格式： //注释文字
2. 多行注释<br>
   格式：/* 注释文字 */
   <br>

使用细节：

- 被注释的文字，不会被JVM解释执行
- 多行注释里面不允许有多行注释嵌套

3. 文档注释
   定义：注释内容可以被JDK提供的工具`javadoc`所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在类
   <br>

```java
javadoc-
d 文件名-author-version...Demo.java
```

| 标签          | 描述                                       | 示例代码                                                           |
|:------------|:-----------------------------------------|:---------------------------------------------------------------|
| @author     | 标记一个类的作者                                 | @author description                                            |
| @deprecated | 描述一个过期的类或成员                              | @deprecated description                                        |
| @docRoot    | 指明当前文档根目录的路径                             | Directory Path                                                 |
| @exception  | 标志一个类抛出的异常                               | @exception exception-name explanation                          |
| @inheritDoc | 从直接父类继承的注释                               | Inherits a comment from the immediate super class.             |
| @link       | 插入一个到另一个主题的链接                            | {@link name text}                                              |
| @linkplain  | 插入一个到另一个主题的链接,但是该链接显示纯文本文字               | Insert an in-line link to another topic                        |
| @param      | 说明一个方法的参数                                | @param parameter-name explanation                              |
| @return     | 说明返回值类型                                  | @return explanation                                            |
| @see        | 执行到另一个主题的链接                              | @see author                                                    |
| @serial     | 说明一个序列化属性                                | @serial description                                            |
| @serialData | 说明通过writeObject() 和writeExternal()方法写的数据 | @serialData description                                        |
| @since      | 表一当前引入一个特定的变化时                           | @since release                                                 |
| @throws     | 和 @exception 标签一样                        | the @throw tag has the same meaning as the @exception tag.     |
| @value      | 显示常量的值，该常量必须是static属性。                   | Display the value of a constant, which must be a static field. |
| @version    | 指定类的版本                                   | @version info                                                  |

<br>
<br>
<br>
<br>
##### Java 代码规范

1. 类、方法的注释，要以javadoc的方式来写。
2. 非 Java Doc的注释，往往是给代码的维护者看的，着重告诉读者为什么这样写
3. 使用tab操作，实现缩进，默认整体向右边移动，使用 `shift + tag` 整体向左移动
4. 运算符和 = 两边习惯各加一个空格。
5. 源文件使用utf-8编码
6. 行宽高度不要超过80字符
7. 代码编写次行风格和尾行风格

# 第三章 变量

目录：

- 变量介绍
- +号的使用
- 数据类型
- 编码
- 数据类型转换

##### 变量的介绍

- 概念：
    - 变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量（值）。
- 变量使用细节
- 变量表示内存中的一个存储区域【不同的变量，类型不同，占用的空间大小不同，比如int 4个字节，double 8个字节】
- 该区域有自己的名称[变量名] 和 类型[数据类型]
- 变量必须先声明，后使用，既有顺序
- 该区域的数据可以在同一类型范围内不断变化
- 变量在同一个作用域内不能重名
- 变量=变量名+值+数据类型。`（变量三要素）`

##### `+` 号的使用

1. 当左右两边都是数值时，则做加法运算
2. 当左右两边一方为字符串，则做拼接。
3. 运算顺序，是从左往右

##### `Java` 数据类型

Java 数据类型

- 基本数据类型
    - 数值型
        - 整数类型（byte[1],short[2],int[4],long[8]）
        - 浮点类型（float[4],double[8]）
    - 字符类型（char[2]）
    - 布尔型(boolean[1])
- 引用数据类型
    - 类（class）
    - 接口（interface）
    - 数组（[]）

> 整数的类型

| 类型         | 占用空间 | 范围                                            |
|:-----------|:-----|:----------------------------------------------|
| byte[字节]   | 1字节  | -2^8 ~ 2^8 -1  <br> -128 ~ 127                |
| short[短整形] | 2字节  | -（2^15）~ （2^15）-1 <br> -32768 ~ 32767         |
| int[整形]    | 4字节  | -（2^31）~ （2^31）-1 <br> -213783648 ~ 213783647 |
| long[长整形]  | 8字节  | -（2^63）~ （2^63）-1                             |

<br>

使用细节：

- java各整数类型有固定的范围和字段长度，不受具体操作系统的影响，以保证java程序的可移植性。
- java的整型常量默认为int型，声明long型常量须后加`L`
- java程序中限量常声明为int型，除非不足以表示大数，才使用long
- bit：计算机中最小存储单位。byte：计算机中基本存储单元，1byte=8bit。

> 浮点类型

java的浮点类型可以表示一个小数。

| 类型        | 占用空间 | 范围                      |
|:----------|:-----|:------------------------|
| 单精度float  | 4字节  | -3.403E38 ~ -3.403E38   |
| 双精度double | 8字节  | -1.798E308 ~ -1.798E308 |

说明：

- 关于浮点数在机器中存放形式的简单说明，浮点数=符号位+指数位——尾数位
- 尾数部分可能丢失，造成进度损失（小数都是近似值 ）

使用细节：

- 与整数类型类似，java浮点类型也有固定的范围和字段长度，不受OS的影响。
- java的浮点型常量默认为double，声明float需要加后缀`f`
- 浮点型有两种表示方式
    - 十进制：5.12 ，512.0f，.512
    - 科学计数法: 5.12e2, 5.12E-2
    - 通常情况下，应该使用double，因为比float更加精确。

> 字符类型

基本介绍：<br>
字符类型可以表示单个字符，字符类型是char，char是两个字节（可以存放汉字），
多个字符我们用字符串String

<br>

字符类型使用细节：

1. 字符类型是用单引号括起来的单个字符
2. java中还允许使用转义字符来将其后的字变为特殊字符型常量  `char c3 = '\n'`
3. 在java中，char的本质是一个整数，在输出时，是unicode码对应的字符。
4. 可以直接给char赋一个整数，然后输出时，会按照对用的unicode字符输出。
5. char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码。

<br>

字符本质探讨：

1. 字符型存储到计算机中，需要将字符对应的码值找出来
    - 存储：'a' ==> 码值97 ==> 二进制 ==> 存储
    - 读取：二进制 ==> 97 ==> 'a' ==> 显示
2. 字符和码值的对应关系是通过字符编码表决定的

- Unicode(Unicode编码表固定大小的编码，使用两个字节来表示字符，字母和汉字统一都是占用两个字节，这样浪费空间)
- utf-8:（编码表，大小可变的编码 字母使用1个字节，汉字使用3个字节）

<br>

> 布尔类型:boolean

基本介绍：

1. 布尔类型类型数据只允许取true或false，无null
2. boolean占一个字节。
3. boolean类型适用于逻辑运算，一般用于程序流程控制

- if
- while
- do-while
- for

##### 基本数据类型转换

自动类型转换：<br>
当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换。
<br>
转换规则：

- char -> int -> long -> float -> double
- byte -> short -> int -> long -> float -> double

<br>

使用细节：

1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种类型，然后再进行运算
2. 当我们把`精度大`的数据类型赋值给`精度小`的数据类型时，就会报错，反之就会进行自动类型转换。
3. （byte、short）和char 之间不会自动转换
4. byte、short、char它们可以计算，在计算时首先转换为int类型。
5. boolean不参与转换
6. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型

##### 强制类型转换

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符`()`，但可能造成精度降低或溢出，格外要注意。

<br>

强制类型转换细节：

1. 当进行数据的大小 从 大 -> 小， 就需要进行强制类型转换
2. 强转符号只针对于最近的操作数有效，往往会使用小括号提升优先级。
3. char类型可以保存int的常量值，但不能保存int的变量值，需要强转
4. byte和short类型在进行运算时，当做int类型处理

##### 基本数据类型和String类型的转换

介绍：

- 在程序开发中，我们经常需要将基本数据类型转成String类型。或者将String类型转换成基本数据类型。

基本类型转String类型

- 语法：将基本数据类型的值 +"" 即可。

String类型转基本数据类型

- 通过基本类型的包装类调用parseXX方法即可。

<br>

基本数据类型和String类型的转换注意事项：

1. 在String乐行转成基本数据类型时，要确保String类型能够转成有效的数据，比如我们可以把"123" 转成一个整数，但不能把"hello"
   转成一个整数
2. 如果格式不正确，就会抛出异常，程序就会终止，这个问题在异常处理章节中会处理。

# 第四章：运算符

目录：

- 运算符介绍
- 算数运算符
- 关系运算符
- 逻辑运算符
- 赋值运算符
- 三元运算符
- 运算符优先级

##### 运算符介绍

运算符是一种特殊符号，用以表示数据的运算、赋值和比较等。

1. 算数运算符
2. 赋值运算符
3. 关系运算符
4. 逻辑运算符
5. 位运算符【需要二进制基础】
6. 三元运算符

算数运算符：<br>
算数运算符是对数值类型的变量进行运算的，在Java程序中使用非常多。

关系运算符：<br>

1. 关系运算符的结果都是boolean类型。
2. 关系表达式经常在if结果的条件中或循环结构的条件中。
3. 包含（==,!=,...,instanceof().）

逻辑运算符：<br>
用于连接多个条件（多个关系表达式），最终的结果也是一个boolean。

1. 短路与 &&, 短路或||,取反 ！
2. 逻辑与 &, 逻辑或 |, ^ 逻辑疑惑

| a | b | a&b | a&&b | a\|b | a\|\|b | !a | a^b |
|:--|:--|:----|:-----|:-----|:-------|:---|:----|
| T | T | T   | T    | T    | T      | F  | F   |
| T | F | F   | F    | T    | T      | F  | T   |
| F | T | F   | F    | T    | T      | T  | T   |
| F | F | F   | F    | F    | F      | T  | F   |

a^b: 当a和b不同时，则为true，否则为false.

&&: 如果第一个条件为false，则第二个条件不会判断，最终结果为false，效率高

&: 不管第一个是否为false，第二个条件都要判断，效率低。

开发中，基本上都是使用&&，效率高.

赋值运算符：<br>
赋值运算符就是将某个运算后的值，赋给指定的变量；

##### 三元运算符

语法：条件表示 ? 表达式1 ： 表达式2；

细节：

- 表达式1 和表达式2 要为可以赋给接受变量的类型（或可以自动转换）
- 三元运算符可以转换成if-else语句

##### 标识符的命名规则和规范

1. java对各种变量、方法和类等命名时使用的字符序列称为标识符
2. 凡事自己可以起名字的地方豆角标识符 `int num = 90;`
3. 标识符命名规则

- 由26个英文字母大小写，0-9，_或$ 组成
- 不能用数字开头
- 不可以使用关键字和保留字，但能包含关键字和保留字。
- java中严格区分大小写，长度无限制。
- 标识符不能包含空格。

##### 标识符的命名规则和规范

1. 包名：多单词组成时所有字母都小写. aaa.bbb.ccc // com.iamhotcenplotz.www
2. 类名、接口名：多单词组成时，所有单词的首字母大写。 XxxYyyZzz, TankShotGame
3. 变量名、方法名: 多单词组成时，第一个单子首字母小写，第二个单词开始单词首字母大写：xxxYyyZzz, tankShotGame
4. 常量名：所有字母都大写。多单词时每个单词用下划线连接：ZZZ_YYY_XXX,TAX_RATE
5. 后面我们学习类、包、接口等时，我们的命名规范要这样遵守。

##### 进制

1. 二进制：0，1，以0b开头
2. 八进制：以0开头
3. 十六进制：0-9及A（10）-F（15），以0X开头

##### 二进制在运算中的说明

1. 二进制时逢2进位的进位制，0、1时基本算符
2.

现代的电子计算机技术全部采用的是二进制，因为它只使用0、1两个数字符号，非常简单方便，易于用电子方式实现。计算机内部处理的信息，都是采用二进制数来表示的。二进制数用0和1两个数字及其组合来表示任何数。进位规则是"
逢二进一"，数字1在不同的位上代表不同的值，按从右到左的次序，这个值以两倍递增。

##### 原码、反码、补码

1. 二进制最高位是符号位：0表示整数，1表示负数
2. 正数的原码、反码、补码都是一样的
3. 负数的反码=它的原码符号位不变，其他位取反。
4. 负数的补码=它的反码+1，负数的反码=负数的补码-1.
5. 0的反码、补码都是0
6. java没有无符号数，换言之，java中的数都是有符号的。
7. 在计算机运算的时候，都是以补码的方式来运算的。
8. 当我们看运算结果的时候，要看他的原码。

##### 位运算符

1. 算数右移 >> : 低位溢出，符号位不变，并用符号位补溢出的高位
2. 算数左移 << : 符号位不变，低位补0
3. `>>>` : 逻辑右移，页脚无符号位右移，运算规则是：低位溢出，高位补0
4. 特别说明：没有 `<<<` 符号
5. &：两个全为1，结果为1，否则0
6. |：两个右一个为1，结果为1，否则0
7. ^: 一个0一个1，结果为1，否则0
8. ~： 0变1，1变0

# 第五章：程序控制结构

目录：

- 顺序控制
    - 程序从上到下逐行执行，中间没有任何判断和跳转。
- 分支控制
- 循环控制
- break
- continue
- return

##### switch

1. switch 关键字表示switch分支
2. 表达式对应一个值
3. case常量1：当表达式的值等于常量1，就执行语句块1
4. break：表示退出switch
5. 如果case常量1匹配，就执行语句块1，如果没有匹配就继续匹配case常量2.
6. 如果一个都没有匹配上，执行default

##### for loop

死循环示例：

```java
for(;;){

        }

```

##### while loop

```java
while(){

        }
```

```java
do{

        }
        while();


```

##### break,continue

```java
if(...){...break;}

        if(...){...continue;}

```

##### return

return 使用在方法，表示跳出所在的方法，在讲解方法的时候，会详细的介绍。

# 第六章：数组、排序和查找

目录：

- 数组
- 排序
- 查找
- 多维数组

##### 为什么需要数组？

一个农场由6只鸡，它们的体重分别是...,请问它们的平均体重是多少？<br>
ok~ 六只鸡定义变量还好说。那么200只鸡呢？

##### 数组

数组可以存放多个`同一类型`的数据。数组也是一种数据类型，是引用类型。

##### 数组的两种使用方式

1. 动态初始化: int a = new int[5]; ---> int a[]; a= new int[5];
2. 静态初始化：int a[] = {1,2,3,4,5,6,7,8,9,10}

##### 数组使用注意事项和细节

1. 数组是多个相同类型数据的组合，实现对这些数据的统一管理
2. 数组中的元素可以使任何数据类型，包括基本类型和引用类型，但是不能混用
3. 数组创建后，如果没有赋值则使用默认值

- int：0
- short：0
- byte：0
- long：0
- float：0.0
- double：0.0
- char：\u0000
- boolean: false
- String: null

4. 数组的的步骤：声明数组并开辟空间 --> 给数组各个元素赋值 --> 使用数组
5. 数组的下表从0开始
6. 数组下表必须在指定范围内使用，否则报错：下表越界异常。
7. 数组属于引用数据类型，数组型数据是对象（object）

##### 数组赋值机制

1. 十几本数据类型赋值，这个值就是具体的数据，而且互不影响
2. 数组在默认情况下是引用传递，赋的值就是地址。

```java
int[] arr1 = {1, 2, 3};
int[] arr2 = arr1[];
```

##### 排序

排序是将一群数据，依指定的顺序进行排列的过程。
排序分类：

- 内部排序：将需要处理的所有数据都加载到内部存储器中进行排序。包括（交换式排序法，选择式排序法和插入式排序法）
- 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接排序法）

冒泡排序：通过对待排序序列从后向前，依次比较相邻元素的值，若发现逆序则进行交换，使值较大的元素逐渐从前向后补移动，就像水底的气泡一样逐渐向上冒。

##### 查找

1. 顺序查找
2. 二分查找

##### 多维数组---> 二维数组

# 第七章: 面相对象编程（基础）

##### 目录

- 类与对象
- 成员方法
- 成员方法传参机制
- 重载（overload）
- 可变参数
- 作用域
- 构造器
- this

##### 类与对象

- 一个养猫的问题:
    - 老陈太太养了两只猫：一只小白，今年3岁，白色。一只小华，5岁，花色。编写一个程序，当用户输入小猫的名字时，显示名字、年龄、颜色。如果小猫名字错误，则显示没有这只猫。
- 一个程序就是一个世界，有很多事物（对象【属性、行为】）
- 注意细节
    - 属性的定义语法同变量；示例：访问修饰符 属性类型 属性名
    - 属性的定义类型可以为任意类型，包含基本类型或引用类型
    - 属性如果不赋值，有默认值，规则和数组一致。

##### 成员方法

在某些情况下，我们需要定义成员方法。比如人类：除了一些属性外，还有一些行为。这时就需要成员方法。

使用细节：

- 修饰符：（作用是控制方法的使用范围；有四种可选[public,private,protected,default]）
- 返回类型：
    - 一个方法最多由一个返回值
    - 返回类型可以为任意类型，包含基本类型和引用类型
    - 如果方法要求有返回数据类型，则方法体中最后的执行语句必须是return值；而且要求返回值类型必须和return的类型一致或兼容
    - 如果方法是void，则方法体中可以没有return语句，或者只写erturn；
    - 方法名：遵循小驼峰。

形参列表：

- 一个方法可以由0个参数，也可以由多个参数，中间用逗号隔开。
- 参数类型可以为任意类型，包含基本类型或引用类型。
- 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数
- 方法定义时的参数称为形式参数，简称形参；方法调用时的参数称为实参，实参和形参的类型要一直或兼容、个数、顺序必须一致。

方法体： 里面写完成功能的具体语句，方法体不能嵌套方法（python可以）。

##### 方法递归调用

简单说：递归就是方法自己调自己，每次调用时传入不同的变量。递归有助于解决复杂问题，同时使代码变得简洁。

递归的重要规则：

- 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
- 方法的局部变量是独立的，不会互相影响。
- 如果方法中使用的引用类型变量（比如数组），就会共享该引用类型的数据
- 递归必须有退出递归的条件，否则是无限递归，会出现 StackOverflowError
- 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

##### 方法重载（overload）

java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致

好处：减轻了起名和记名的麻烦

##### 可变参数

java允许将同一个类中的多个同名功能但参数个数不同的方法，封装成一个方法。

##### 作用域

在面向对象中 ，变量作用域是非常重要的知识点，相对来说不是特别好理解。

- 在java中，主要的变量就是属性和局部变量。
- 我们说的局部变量一般是指在成员方法中定义的变量
- java中作用域的分类：
    - 全局变量：也就是属性，作用域为整个类体
    - 局部变量：也就是除了属性之外的其他变量，作呕你与定义它的代码块中
- 全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值。

使用细节：

- 属性和局部变量可以重名，访问时遵循就近原则
- 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。
- 属性声明周期较长，伴随着对象的创建而创建，伴随着对象的消亡而消亡。局部变量，声明周期较短，伴随着它的代码块的执行而创建，伴随着代码块的的消亡而消亡。即在一次方法调用过程中。

##### 构造方法/构造器

- 构造器的修饰符可以默认
- 构造器没有返回值
- 方法名和类型必须一致
- 参数列表和成员方法一样的规则
- 构造器的调用系统完成。

构造器使用细节：

- 一个类可以定义多个不同的构造器，即够再起重载
- 构造器名和类名要相同
- 构造器没有返回值
- 构造器是完成对象的初始化，不是创建对象
- 在创建对象时，系统自动的调用该类的构造方法。
- 如果没有指定构造方法，系统会自动给类生成一个默认的无参构造方法（也叫默认构造方法），可以使用javap执行反编译看看
- 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的无参构造器。

##### this

java虚拟机会给每个对象分配this，代表当前对象。

# 第八章：面向对象编程（中级）

目录：

- 包
- 访问修饰符
- OOP三大特征
- Super关键字
- 方法重写（overwrite）
- Object类详解，垃圾回收机制

##### 包

实际上就是创建的不同的文件夹来保存文件。

包命名规范：

- 只能包含数字、字母、下划线、小圆点。但不能用数字开头，不能用关键字或保留字
- 一般是小写字母+小圆点
    - com.公司名.项目名.业务模块名

##### 访问修饰符

java提供四种访问控制修饰符，用于控制方法和属性的访问权限（范围）

1. public: 对外公开
2. protected: 对子类和通一个包中的类公开
3. default: 向同一个包的类公开
4. private： 只有类本身可以访问，不对外公开

##### 封装

封装（encapsulation）就是把抽象出的数据和对数据的操作封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作，才能对数据进行操作。

##### 继承

继承可以解决代码复用，让我们的编程更加接近人类思想。当多个类存在相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，
所有的子类不需要重新定义这些属性和方法，只需要通过`extends`来声明继承父类即可

1. class子类extends父类{}
2. 子类就会自动拥有父类定义的属性和方法
3. 父类又叫超类，基类。
4. 子类又叫派生类。

继承的好处：

1. 代码的复用性提高了
2. 代码的扩展性和维护性提高了

继承细节：

1. 子类必须调用父类的构造器，完成父类的初始化
2. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去嗲用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不会通过
3. 如果希望指定去嗲用父类的某个构造器，则显示调用一下。
4. super在使用时，需要放在构造器第一行
5. super() 和 this() 都只能放在构造器第一行，因此这两个方法不能存在一个构造器。
6. java所有类都是Object类的子类。
7. 父类构造器的调用不限于直接父类，将一致网上赘述直到Object类。
8. 子类最多只能继承一个父类，即java中的单继承机制
9. 不能滥用继承，子类和父类必须满足 is-a 的逻辑关系

##### Super 关键字

Super代表父类的引用，用于访问父类的属性、方法、构造器。

1. 调用父类构造器的好处：分工明确，父类属性由父类初始化，子类属性由子类初始化。
2. 当子类中有和父类成员重名时，为了访问父类成员，必须使用super。如果没重名，使用super或this效果都是一样的。
3. super的访问不限于父类，如果爷爷类和本类有重名的成员，也可以使用super去访问爷爷类成员；如果多个基类中都有同名的成员，使用super访问，遵循就近原则。

| No. |  区别点  |            this            |        super        |
|:---:|:-----:|:--------------------------:|:-------------------:|
|  1  | 访问属性  | 访问本类中的属性，如果本类没有此属性则从父类继续寻找 |      访问父类中的属性       |
|  2  | 调用方法  | 访问本类中的方法，如果本类没有此方法则从父类继续寻找 |      访问父类中的方法       |
|  3  | 调用构造器 |     调用本类构造器，必须放在构造器首行      | 调用父类构造器，必须放在子类构造器首行 |
|  4  |  特殊   |           表示当前对象           |      子类中访问父类对象      |



##### 方法的重写

简单的说：方法重写就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那我们就说子类的这个方法，覆盖了父类的那个方法。


##### 多态

多态可以提高代码的复用性。

多态的基本介绍：
方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。具体表现有
- 方法的多态(通过方法的重写/重载来体现多态)
- 对象的多态（通过继承来体现多态）
  - 一个对象的编译类型和运行类型可以不一致
  - 编译类型在定义对象时，就确定了，不能改变
  - 运行类型是可以变化的
  - 编译类型看定义时 = 号的左边， 运行类型看 = 号的右边


多态注意事项和细节：
- 多态的前提是：两个对象存在继承关系
- 多态的向上转型
- 本质：父类的引用指向了子类
- 语法：父类类型 引用名 = new 子类类型();
- 特点： 编译类型看左边，运行类型看右边。可以调用父类中的所有成员（需要遵守访问权限），不能调用子类中的特有成员；最终运行效果看子类的具体实现。

多态的向下转型：
- 语法：子类类型 引用名 = (子类类型) 父类引用；
- 只能强转父类的引用，不能强转父类的对象
- 要求父类的引用必须指向的是当前穆雷类型的对象
- 可以调用子类类型中的所有成员

多态的属性没有重写之说，属性的值看编译类型。


多态参数：
- 方法定义的形参类型为父类类型，实参类型允许为子类类型

##### 动态绑定机制

1. 当调用对象方法时，该方法会和对象的内存地址/运行类型绑定
2. 当调用对象属性时，没有动态绑定机制，哪里声明哪里使用


##### Object 详解

- == 和 equals 对比
  - == 是一个比较运算符
    - 即可以判断基本类型，又可以判断引用类型
    - 如果判断基本类型，判断的是值是否相等。
    - 如果判断的引用类型，则判断内存地址是否相等。
  - equals 是Object的类中的方法，只能判断引用类型
- hashCode
  - 提高具有哈希结构的容器的效率
  - 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的。
  - 两个引用，如果指向不同对象，则哈希值是不一样的。
  - 哈希值主要根据地址号来的，不能完全将哈希值等价于地址
- toString
  - 全类名 + @ + 哈希值的十六进制
- finalize
  - 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，左一些释放资源的操作。
  - 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象时一个垃圾对象，就会使用垃圾回收期来销毁该对象，在销毁该对象前，会先调用finalize方法。
  - 垃圾回收机制的调用，是由系统来决定，也可以通过System.gc() 主动触发垃圾回收机制。


# 第九章: 小项目-房屋出租系统

小项目：房屋出租系统

# 第十章：面向对象编程（高级部分）

##### 本章内容
- 类变量和类方法
- 理解main方法语法 static 
- 代码块
- 单例设计模式
- final 关键字
- 抽象类
- 接口
- 内部类

##### 类变量和类方法
- 类变量
  - 类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，渠道的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。
  - static 变量是所有该类对象所共享的。
  - static 变量是在类加载的时候生成的。
  - 使用细节：
    - 什么时候用？当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量
    - 类变量与类实例的区别：类变量时该类的所有对象共享的，而实例变量是每个变量独享的。
    - 加上static称为类变量或静态变量，否则称为实例变量
    - 变量时再类加载时就初始化了，也就是说，基石你没有创建对象，只要类加载了，就可以使用类变量了。
    - 类变量的声明周期是随类的加载开始的，随着类消亡而消亡

- 类方法
  - 经典使用场景：当方法中不涉及到任何和对象先关的成员，则可以将方法设计成静态方法，提高效率。比如工具类：utils
  - 注意事项：
    - 类方法和普通方法都是随着类加载而加载，将结构信息存储在方法区：类方法中无this的参数
    - 类方法可以通过类名调用，也可以通过对象名调用

- main 方法
  - java虚拟机需要调用main()方法，所以该方法的访问权限必须是public
  - java虚拟机在执行main方法时不必创建对象，所以该方法必须是static
  - 该方法接受String类型的数组参数，该数组中保存执行java命令时所传递给所运行的类的参数

- 代码块
  - 代码块又称初始化块，属于类中的成员，类似于方法，将逻辑语句封装子啊方法体中，通过{} 保卫起来。但和方法不同，没有方法名，没有返回，没有参数，只又方法体，而且不能通过对象或类显示调用，而是加载类时，或创建对象时隐式调用。
  - 使用细节
    - static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，没创建一个对象，就执行。
    - 类什么时候被加载
      - 创建对象实例时（new）
      - 创建子类对象实例，父类也会被加载
      - 使用类的静态成员时
    - 普通的代码块，在创建对象实例时，会被隐式调用。被创建一次，就会调用一次。如果是使用类的静态成员时，普通代码块并不会执行。
    - 创建一个对象时，一个类被调用的顺序是：
      - 调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用）
      - 调用普通代码块和普通属性的的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按照定义顺序调用）
      - 调用构造器方法
    - 构造方法（构造器）里头的super(),在类加载时就执行完毕，因此优先于构造器和普通代码块
    - 创建子类时（继承关系）静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：
      - 父类的静态代码块和静态属性
      - 子类的静态代码块和静态属性
      - 父类的普通代码块和普通属性初始化
      - 父类的构造器
      - 自理的普通代码块和普通属性初始化
      - 子类的构造器
    - 静态代码块值能直接调用静态成员，普通代码块可以调用任意成员。


##### 单例模式

什么是设计模式？
1. 静态方法和属性的经典使用
2. 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以解决问题的思考方式。设计模式就像经典的棋谱，不同的棋局，我们用不同的棋谱，免去我们自己再思考和摸索。

什么是单例模式？
1. 所谓的单例模式，就是采取一定的方法在整个的软件系统中，对某个类只能存在一个实例对象，并且该类只提供一个取得对象实例的方法
2. 单例模式有两种方式：饿汉式；懒汉式

##### final 关键字

final 可以修饰类、属性、方法和局部变量

1. 当不希望类被继承时，可以用final
2. 当不希望父类和某个方法被子类覆盖\重写时，可以用final关键字修饰
3. 当不希望类的某个属性的值被修改，可以用final修饰
4. 当不希望某个局部变量被修改可以用final 修饰
5. 一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法
6. final不能修饰构造器
7. final 和 static 往往搭配使用，效率更高，底层编译器做了优化处理
8. 包装类（Integer、Double、Float，Boolean、String 等）都是final类

##### 抽象类

当父类的某些方法需要声明，但是又不确定何时实现时，可以将其生命为抽象方法，那么这个类就是抽象类.

抽象类介绍：
1. 用abstract 关键字来修饰一个类时，这个类就叫抽象类
2. 用abstract 关键字来修饰一个方法时，这个方法就是抽象方法
3. 抽象类的价值更多作用于设计，是设计者设计好后，让子类继承并实现抽象类。
4. 抽象类，在框架和设计模式使用比较多。


使用细节：
1. 抽象类是不能实例化的。
2. 抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法
3. 一旦包含了abstract方法，则这个类必须声明为abstract
4. abstract 只能修饰类和方法，不能修饰属性和其它。
5. 抽象类可以由任意成员【抽象类还是类】，比如：非抽象方法、构造器、静态属性等等。
6. 抽象方法不能由主体，即不能实现（就是方法名后 不要跟{}）
7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为抽象类。
8. 抽象方法不能使用private、final 和static 来修饰，因为这额关键字都是和重写相违背的。


最佳实践：模版设计模式


##### 接口

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来

接口注意事项：
1. 接口不能被实例化
2. 接口中所有方法时public方法，接口中抽象方法，可以不用abstract修饰
3. 一个普通类实现接口，就必须将该接口的额所有方法实现。
4. 抽象类实现接口，可以不用实现接口方法。
5. 一个类同时可以实现多个接口
6. 接口中的属性，只能是final，而且是 public static final 
7. 接口中的属性的访问方式：接口名.属性名
8. 一个接口不能继承其他的类，但是可以继承多个别的接口


##### 内部类

一个类的内部又完整的嵌套了另一个类结构。是类的第五大成员（属性、方法、构造器、代码块、内部类）。内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。


内部类的分类：
- 定义在外部类局部位置上（比如方法内）
  - 局部内部类（有类名）
    - 可以直接访问外部类的所有成员，包含私有的
    - 不能添加访问修饰符，因为它的低位就是一个局部变量。局部变量时不能使用修饰符的。但是可以使用final修饰，因为局部变量可以使用final
    - 作用域：仅仅在定义它的方法或代码块中使用
    - 局部内部类 ---> 访问 ---> 外部类的成员【直接访问】
    - 外部类 ---> 访问 ---> 局部内部类成员； 访问方式： 创建对象再访问（必须在作用域内）
    - 外部其他类 ---> 不能访问 ---> 局部内部类 （因为局部内部类的低位是一个局部变量）
    - 如果外部类和局部内部类的成员重名，默认遵循就近原则，如果向访问外部类的成员则可以使用 外部类.this.成员 去访问
  - 匿名内部类（没有类名）
    - 本质是类
    - 还是一个内部类
    - 该类没有类名（但是系统给自动取了个名）
    - 同时还是一个对象
    - 可以直接访问外部类的所有成员，包括私有的
    - 不能添加访问修饰符
    - 仅在方法或代码块中有效
    - 外部其他类不能访问内部匿名类
    - 如果外部类和局部内部类的成员重名，默认遵循就近原则，如果向访问外部类的成员则可以使用 外部类.this.成员 去访问
- 定义在外部类的成员位置上
  - 成员内部类（没有static修饰）
    - 成员内部类时定义在外部类的成员位置，并且没有static修饰
    - 可以直接访问外部类的所有成员，包括私有
    - 可以添加任意访问修饰符 public protected default private,因为它的低位就是一个成员
    - 作用域：和外部类的成员一样，为整个类体；
  - 静态内部类（使用static修饰）
    - 可以直接访问内部类的所有静态成员，包含私有的，不能直接访问非静态成员


# 第十一章：枚举和注解
目录：
- 枚举介绍
- 自定义实现枚举
- enum关键字实现枚举
- JDK内置的基本注解类型
- 元注解：对注解进行注解

##### 枚举

枚举是一组常量的集合

实现总结：
1. 构造器私有化
2. 奔雷内部创建一组对象
3. 对外暴露对象  public final static
4. 可以提供get，但不提供set
5. 不能继承，但是可以实现接口

##### 注解：Annotation

1. 注解也被称为元数据，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息
2. 和注解一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入代码的补充信息
3. 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等，在JavaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版本中所遗留的繁冗代码和XML配置等。

四个基本的Annotation
1. @Override: 重写
2. @Deprecated: 已过时
3. @SuppressWarnings: 抑制编译器警告
4. @Target: 是修饰注解的注解，被称为元注解。


# 第十二章：异常

目录：
- 异常的概念
- 异常体系图
- 常见的异常
- 异常处理概念
- 异常处理分类
- 自定义异常
- throw 和 throws 对比


##### 异常介绍

java语言中，将程序执行中发生的不恒昌情况称为异常。
执行过程中所发生的异常事件可分为两类：
- Error：Java虚拟机无法解决的问题。如JVM系统内部错误、资源耗尽等严重情况，再比如：StackOverFlowError和OOM等严重错误。
- Exception： 其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如空指针访问，视图读取不存在的文件，网络连接中断等等。
  - Exception：
    - 运行时异常
    - 编译时异常

##### 异常体系图

Throwable
- Error
  - StackOverflowError
  - OutOfMemoryError
  - ...
- Exception
  - IOException
  - RuntimeException
  - 。。。

说明：
- 异常分为两大类，运行时异常和编译时异常
- 运行时异常，编译器不要求强制处理的异常。一般是指编程时的逻辑错误，是程序员应该避免其出现的异常。java.lang.RuntimeException 类及它的子类都是运行时异常
- 对于运行时异常，可以不做处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生过影响
- 编译时异常，是编译器要求必须处理的异常。

##### 常见的运行时异常

1. NullPointerException空指针异常
2. ArithmeticException数学运算异常
3. ArrayIndexOutOfBoundsException数组下标越界异常
4. ClassCastException类型转换异常
5. NumberFormatException数字格式不正确异常


##### 编译异常

编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译。

常见的编译异常：
- SQLException 操作数据库时，查询表可能发生异常
- IOException 操作文件时，发生的异常
- FileNotFoundException 当操作一个不存在的文件时，发生异常
- CLassNotFoundException 加载类，该类不存在，异常
- EOFException 操作文件，到文件末尾发生异常
- IllegalArgumentException 参数异常

##### 异常处理

异常处理方式：
- try-catch-finally
  - 程序员在代码中捕获发生的异常，自行处理
- throws
  - 将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是jvm


##### throws异常处理
1. 如果一个方法（中的语句执行时）可能发生某种异常，但是并不确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。
2. 在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类

##### 自定义异常
1. 定义类：自定义异常类名，继承Exception 或RuntimeException
2. 如果继承Exception，属于编译异常
3. 如果继承RuntimeException，属于运行异常（一般来说，继承RuntimeException）


# 第十三章：常用类

目录：
- 包装类
- String类
- StringBuffer和StringBuilder类
- Math类
- Date日期类、Calendar日历类以及新的日期
- System类
- Arrays类
- BigInteger和BigDecimal


##### 包装类
1. 针对八种基本定义的数据类型相对的引用类型-包装类
- boolean:Boolean
- char: Character
- byte: Byte
- short: Short
- int: Integer
- long: Long
- float: Float
- double: Double

##### String

1. String 对象用于保存字符串，也就是一组字符序列
2. 字符串的字符使用Unicode字符编码，一个字符（不区分大小写和汉字）占两个字节。

##### StringBuilder

1. 一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步（StringBuilder不是线程安全。）该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。
如果可能，建议有限采用该类，因为在大多数视线中，它比StringBuffer要快。

2. 在StringBuilder上的主要造作是append和insert方法，专科重载这些方法，以接受任意类型的数据。


##### String VS StringBuilder VS StringBuffer

1. StringBuilder 和StringBuffer 非常类似，均代表可变字符序列，而且方法也一样。
2. String: 不可变字符序列，效率低，但是复用率高。
3. StringBuffer: 可变字符序列，效率高（增删），线程安全
4. StringBuilder: 可变字符序列，效率最高，线程不安全

使用原则：
1. 如果字符串存在大量的修改操作，一般使用StringBuffer 或 StringBuilder
2. 如果字符串存在大量修改操作，并在单线程中，用StringBuilder
3. 如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer
4. 如果我们字符串很少修改，被多个对象引用，使用String，如配置信息等。

##### Arrays 类

Arrays 里面包含了一些列静态方法，用于管理或操作数组（比如排序和搜索）。

1. toString 返回数组的字符串形式
2. sort 排序
3. binarySearch 通过二分搜索进行查找，要求必须排好序
4. copyOf 数组元素的复制
5. fill 数组元素的填充
6. equals 比较两个数组元素内容是否一致
7. asList 将一组值转成list


##### System 类

1. exit
2. arraycopy
3. currentTimeMillens：返回当前时间距离1970-01-01 00：00：00 的毫秒数
4. gc：运行垃圾回收机制


##### 日期类
1. 第一代：Date
2. 第二代：Calendar
3. 第三代：LocalDateTime  推荐使用

# 第十四章：集合

##### 目录：
1. 集合框架体系图
2. Collection 接口 特点 方法
3. Collection接口的子接口：
   - List实现类：
     - ArrayList
     - LinkedList
     - Vector
4. Collection接口的子接口
 - Set实现类：
   - HashSet
   - LinkedHashSet
   - TreeSet
5. Map接口 特点方法 遍历方法
6. Map接口的实现类：HashMap、Hashtable、LinkedHashMap、TreeMap、Properties
7. Collections工具类的使用

##### 集合的理解和好处

数组：
1. 长度开始时必须指定，而且一旦指定，不能更改
2. 保存的必须为同一类型的元素
3. 使用数组进行增加或删除元素比较麻烦

集合：
1. 可以懂爱保存任意多个对象，使用比较方便
2. 提供了一系列方便的操作对象的方法：add、remove、set、get等
3. 使用集合添加、删除新元素比较简洁

##### 集合的框架体系

- Collection
  - List
    - ArrayList
    - LinkedList
    - Vector
  - Set
    - HashSet
    - TreeSet
- Map
  - HashMap
  - Hashtable
    - Properties
  - TreeMap

##### Collection 接口实现类的特点
1. collection实现子类可以存放多个元素，每个元素可以使Object
2. 有些Collection的实现类，可以存放重复的元素，有些不可以
3. 有些Collection的实现类，有些是有序的（List），有些不是有序的（Set）
4. Collection 接口没有直接的实现子类，是通过它的子接口Set和List来实现的。

##### Collection 接口遍历元素的方式-迭代器
1. Iterator对象称为迭代器，主要用于遍历Collection中的元素。
2. 所有实现了Collection接口的集合类都有一个iterator（）方法，用以返回一个实现了Iterator接口的对象，即一个迭代器
3. Iterator仅用于遍历集合，Iterator本身并不存放对象。


##### List接口和常用方法
1. List集合类中元素使有序的（添加顺序和取数顺序一致）且可重复。
2. List集合中的每个元素都有其对应的顺序索引，即支持索引。
3. List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号去除容器中的元素。

##### ArrayList注意事项
1. permits all elements, including null
2. ArrayList 是由数组来实现数据存储的
3. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高），在多线程情况下，不建议使用

##### ArrayList 底层结构
1. ArrayList中维护了一个Object类型的数组elementData
2. 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementData容量为0，第一次添加，则扩充到10，如果需要再次扩容，则扩容elementDatqa为1.5倍
3. 如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如果需要扩容，则直接扩容elementData为1.5倍

##### Vector 底层结构
1. Vector 底层也是一个对象数组，protected Object[] elementData;
2. Vector 是线程同步的，即线程安全，Vector类的操作带synchronize
3. 在开发中，需要线程同步安全时，使用Vector

##### LinkedList
1. LinkedList 底层实现了双向链表和双端队列的特点
2. 可以先加任意元素（元素可以重复），可以添加null
3. 线程不安全，没有实现同步

LinkedList 底层机制
1. linkedList底层维护了一个双向链表
2. LinkedList中维护了两个属性first和last分别指向第一个和最后一个节点
3. 每个节点（Node），里面又维护了prev、next和item三个属性，其中prev指向前一个，next指向下一个，最终实现双向链表。
4. 所以LinkedList的元素的添加和删除不是通过数组完成的，相对来说效率较高。

##### ArrayList VS LinkedList
1. 如果我们改查的操作多，选ArrayList
2. 如果增删操作多，选LInkedList
3. 一般来说，80% ~ 90% 都是查询，因此大部分情况选择ArrayList


##### Set接口和常用方法

1. 无序（添加和取出顺序不一致），没有索引
2. 不允许添加重复元素，所以最多包含一个null
3. JDK API 中set接口实现类有：AbstractSet，ConcurrentSKipListSet，CopyOrWriteArraySet，EnumSet，HashSet，TreeSet，JobStateReasons，LinkedHashSet。。。
4. 常用方法：
   - 和List接口一样，Set接口也是Collection的子接口，因此常用方法和collection接口一样。
   - Set接口的遍历方式
     - 可以使用迭代器
     - 增强For
     -  `不能使用`索引的方式来获取。
5. HashSet 底层是 HashMap -> [数组+链表+红黑树]
    - HashSet底层是HashMap
    - 添加一个元素时，先得到hash值-会转成索引 -> 索引值
    - 找到存储数据表table，看到这个索引位置是否已经存放有元素
    - 如果没有，直接加入
    - 如果有，调用equals比较，如果相同，就放弃添加，如果不相同，则添加到最后
    - 在Java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD（默认值8），并且table的大小 >= MIN_TREEIFY_CAPACITY(默认64)就会进行树化（红黑树）


##### LinkedHashSet

1. LinkedHashSet 是 HashSet 的子类
2. LinkedHashSet 底层是一个LinkedHashMap，底层维护了一个 数组+双向链表
3. LinkedHashSet 根据元素的HashCode 值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的，
4. linkedHashSet不允许添加重复元素

##### Map接口和常用方法
1. Map与collectin并列存在。用于保存具有映射关系的数据 k-v
2. Map中的key和value可以使任何引用类型的数据，会封装到HashMap$node对象中
3. Map中的key不允许重复
4. Map中的value可以重复
5. Map的key可以为null，value也可以为null，注意 key为null只能有一个
6. 常用String类作为Map的key
7. key和value之间存在单向一对一关系，即通过指定的key总能找到对应的value